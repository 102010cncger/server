var fs = require('fs');var path = require('path');var mkdirp = require('mkdirp');var utils = require('./utils');var crypto = require('crypto');var configStorage = require('config').get('storage');var cfgBucketName = configStorage.get('bucketName');var cfgStorageFolderName = configStorage.get('storageFolderName');var configFs = configStorage.get('fs');var cfgStorageFolderPath = configFs.get('folderPath');var cfgStorageSecretString = configFs.get('secretString');function getFilePath(strPath) {  return path.join(cfgStorageFolderPath, strPath);}function getOutputPath(strPath) {  return strPath.replace(/\\/g, '/');}function removeEmptyParent(strPath, done) {  if (cfgStorageFolderPath.length + 1 >= strPath.length) {    done();  } else {    fs.readdir(strPath, function(err, list) {      if (err) {        //не реагируем на ошибку, потому скорее всего эта папка удалилась в соседнем потоке        done();      } else {        if (list.length > 0) {          done();        } else {          fs.rmdir(strPath, function(err) {            if (err) {              //не реагируем на ошибку, потому скорее всего эта папка удалилась в соседнем потоке              done();            } else {              removeEmptyParent(path.dirname(strPath), function(err) {                done(err);              });            }          });        }      }    });  }}exports.getObject = function(strPath) {  return new Promise(function(resolve, reject) {    fs.readFile(getFilePath(strPath), function(err, data) {      if (err) {        reject(err);      } else {        resolve(data);      }    });  });};exports.putObject = function(strPath, buffer, contentLength) {  return new Promise(function(resolve, reject) {    var fsPath = getFilePath(strPath);    mkdirp(path.dirname(fsPath), function(err) {      if (err) {        reject(err);      } else {        //todo 0666        if (Buffer.isBuffer(buffer)) {          fs.writeFile(fsPath, buffer, function(err) {            if (err) {              reject(err);            } else {              resolve();            }          });        } else {          utils.promiseCreateWriteStream(fsPath).then(function(writable) {            buffer.pipe(writable);          }).catch(function(err) {            reject(err);          });        }      }    });  });};exports.listObjects = function(strPath) {  return utils.listObjects(getFilePath(strPath)).then(function(values) {    return values.map(function(curvalue) {      return getOutputPath(curvalue.substring(cfgStorageFolderPath.length + 1));    });  });};exports.deleteObject = function(strPath) {  return new Promise(function(resolve, reject) {    var fsPath = getFilePath(strPath);    fs.unlink(fsPath, function(err) {      if (err) {        reject(err);      } else {        //resolve();        removeEmptyParent(path.dirname(fsPath), function(err) {          if (err) {            reject(err);          } else {            resolve();          }        });      }    });  });};exports.deleteObjects = function(strPaths) {  return Promise.all(strPaths.map(exports.deleteObject));};exports.getSignedUrl = function(baseUrl, strPath, optUrlExpires, optFilename) {  return new Promise(function(resolve, reject) {    var uri = '/' + cfgBucketName + '/' + cfgStorageFolderName + '/' + strPath;    var url = baseUrl + uri;    var date = new Date();    var expires = Math.ceil(date.getTime() / 1000) + (optUrlExpires || 60);		// отключил время жизни т.к. существует сценарий, при котором объект	// получаемый по ссылке запрашивается после того как закончилось время	// его жизни.    var md5 = crypto.createHash('md5').update(/*expires + */uri + cfgStorageSecretString).digest("base64");    md5 = md5.replace(/\+/g, "-");    md5 = md5.replace(/\//g, "_");    url += ('?md5=' + md5 + '&expires=' + expires);    resolve(utils.changeOnlyOfficeUrl(url, strPath, optFilename));  });};