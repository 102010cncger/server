var pathModule = require('path');var urlModule = require('url');var sqlBase = require('./baseConnector');var docsCoServer = require('./DocsCoServer');var taskResult = require('./taskresult');var logger = require('./../../Common/sources/logger');var utils = require('./../../Common/sources/utils');var constants = require('./../../Common/sources/constants');var commonDefines = require('./../../Common/sources/commondefines');var storage = require('./../../Common/sources/storage-base');var formatChecker = require('./../../Common/sources/formatchecker');var statsDClient = require('./../../Common/sources/statsdclient');var config = require('config');var config_server = config.get('services.CoAuthoring.server');var config_utils = config.get('services.CoAuthoring.utils');var cfgTypesUpload = config_utils.get('limits_image_types_upload');var cfgTypesCopy = config_utils.get('limits_image_types_copy');var cfgImageSize = config_server.get('limits_image_size');var cfgImageDownloadTimeout = config_server.get('limits_image_download_timeout');var SAVE_TYPE_PART_START = 0;var SAVE_TYPE_PART = 1;var SAVE_TYPE_COMPLETE = 2;var SAVE_TYPE_COMPLETE_ALL = 3;var clientStatsD = statsDClient.getClient();function OutputDataWrap(type, data) {  this['type'] = type;  this['data'] = data;}OutputDataWrap.prototype = {  fromObject: function(data) {    this['type'] = data['type'];    this['data'] = new OutputData();    this['data'].fromObject(data['data']);  },  getType: function() {    return this['type'];  },  setType: function(data) {    this['type'] = data;  },  getData: function() {    return this['data'];  },  setData: function(data) {    this['data'] = data;  }};function OutputData(type) {  this['type'] = type;  this['status'] = undefined;  this['data'] = undefined;}OutputData.prototype = {  fromObject: function(data) {    this['type'] = data['type'];    this['status'] = data['status'];    this['data'] = data['data'];  },  getType: function() {    return this['type'];  },  setType: function(data) {    this['type'] = data;  },  getStatus: function() {    return this['status'];  },  setStatus: function(data) {    this['status'] = data;  },  getData: function() {    return this['data'];  },  setData: function(data) {    this['data'] = data;  }};function OutputSfcData() {  this['key'] = undefined;  this['status'] = undefined;  this['url'] = undefined;  this['changesurl'] = undefined;  this['changeshistory'] = undefined;  this['users'] = [];  this['mailMerge'] = undefined;}OutputSfcData.prototype.getKey = function() {  return this['key'];};OutputSfcData.prototype.setKey = function(data) {  return this['key'] = data;};OutputSfcData.prototype.getStatus = function() {  return this['status'];};OutputSfcData.prototype.setStatus = function(data) {  return this['status'] = data;};OutputSfcData.prototype.getUrl = function() {  return this['url'];};OutputSfcData.prototype.setUrl = function(data) {  return this['url'] = data;};OutputSfcData.prototype.getChangeUrl = function() {  return this['changesurl'];};OutputSfcData.prototype.setChangeUrl = function(data) {  return this['changesurl'] = data;};OutputSfcData.prototype.getChangeHistory = function() {  return this['changeshistory'];};OutputSfcData.prototype.setChangeHistory = function(data) {  return this['changeshistory'] = data;};OutputSfcData.prototype.getUsers = function() {  return this['users'];};OutputSfcData.prototype.setUsers = function(data) {  return this['users'] = data;};OutputSfcData.prototype.getMailMerge = function() {  return this['mailMerge'];};OutputSfcData.prototype.setMailMerge = function(data) {  return this['mailMerge'] = data;};function OutputMailMerge(mailMergeSendData) {  if (mailMergeSendData) {    this['from'] = mailMergeSendData.getFrom();    this['message'] = mailMergeSendData.getMessage();    this['subject'] = mailMergeSendData.getSubject();    this['title'] = mailMergeSendData.getFileName();    var mailFormat = mailMergeSendData.getMailFormat();    switch (mailFormat) {      case constants.AVS_OFFICESTUDIO_FILE_OTHER_HTMLZIP :        this['type'] = 0;        break;      case constants.AVS_OFFICESTUDIO_FILE_DOCUMENT_DOCX :        this['type'] = 1;        break;      case constants.AVS_OFFICESTUDIO_FILE_CROSSPLATFORM_PDF :        this['type'] = 2;        break;      default :        this['type'] = 0;        break;    }    this['recordCount'] = mailMergeSendData.getRecordCount();    this['to'] = null;    this['recordIndex'] = null;  } else {    this['from'] = null;    this['message'] = null;    this['subject'] = null;    this['title'] = null;    this['to'] = null;    this['type'] = null;    this['recordCount'] = null;    this['recordIndex'] = null;  }}OutputMailMerge.prototype.getRecordIndex = function() {  return this['recordIndex'];};OutputMailMerge.prototype.setRecordIndex = function(data) {  return this['recordIndex'] = data;};OutputMailMerge.prototype.getTo = function() {  return this['to'];};OutputMailMerge.prototype.setTo = function(data) {  return this['to'] = data;};function getInsertStatisticString(affiliateId, filename, tag) {  var dateNow = sqlBase.getDateTime(new Date());  var commandArg = [affiliateId, filename, dateNow, tag];  var commandArgEsc = commandArg.map(function(curVal) {    return sqlBase.baseConnector.sqlEscape(curVal)  });  return 'INSERT INTO file_statistic2 (fsc_affiliate, fsc_filename, fsc_time, fsc_tag) ' +    'VALUES (' + commandArgEsc.join(', ') + ');';}function insertStatistic(affiliateId, filename, tag) {  return new Promise(function(resolve, reject) {    var sqlCommand = getInsertStatisticString(affiliateId, filename, tag);    sqlBase.baseConnector.sqlQuery(sqlCommand, function(error, result) {      if (error) {        reject(error);      } else {        resolve(result);      }    });  });}function* getOutputData(cmd, outputData, key, status, statusInfo, optConn, optAdditionalOutput) {  switch (status) {    case taskResult.FileStatus.SaveVersion:    case taskResult.FileStatus.UpdateVersion:    case taskResult.FileStatus.Ok:      //todo affilate      var tag;      var affiliateId = 'affiliateId';      switch (cmd.getEditorId()) {        case constants.EDITOR_TYPE_SPREADSHEET: tag = 'open_sheet'; break;        case constants.EDITOR_TYPE_PRESENTATION: tag = 'open_presentation'; break;        default:          tag = 'open_word';          break;      }      yield insertStatistic(affiliateId, cmd.getDocId(), tag);      if(taskResult.FileStatus.Ok == status){        outputData.setStatus('ok');      } else {        outputData.setStatus('updateversion');      }      var command = cmd.getCommand();      if ('open' != command && 'reopen' != command) {        var strPath = key + '/' + cmd.getOutputPath();        if (optConn) {          outputData.setData(yield storage.getSignedUrl(optConn.baseUrl, strPath, null, cmd.getTitle()));        } else if (optAdditionalOutput) {          optAdditionalOutput.needUrlKey = strPath;          optAdditionalOutput.needUrlMethod = 2;        }      } else {        if (optConn) {          outputData.setData(yield storage.getSignedUrls(optConn.baseUrl, key));        } else if (optAdditionalOutput) {          optAdditionalOutput.needUrlKey = key;          optAdditionalOutput.needUrlMethod = 0;        }      }      break;    case taskResult.FileStatus.NeedParams:      outputData.setStatus('needparams');      var settingsPath = key + '/' + 'settings.json';      if (optConn) {        outputData.setData(yield storage.getSignedUrl(optConn.baseUrl, settingsPath));      } else if (optAdditionalOutput) {        optAdditionalOutput.needUrlKey = settingsPath;        optAdditionalOutput.needUrlMethod = 1;      }      break;    case taskResult.FileStatus.Err:    case taskResult.FileStatus.ErrToReload:      outputData.setStatus('err');      outputData.setData(statusInfo);      break;  }}function* addRandomKeyTaskCmd(cmd) {  var task = yield* taskResult.addRandomKeyTask(cmd.getDocId());  cmd.setSaveKey(task.key);}function* saveParts(cmd) {  var result = false;  var saveType = cmd.getSaveType();  var filename;  if (SAVE_TYPE_COMPLETE_ALL === saveType) {    filename = 'Editor.bin';  } else {    filename = 'Editor' + (cmd.getSaveIndex() || '') + '.bin';  }  if (SAVE_TYPE_PART_START === saveType || SAVE_TYPE_COMPLETE_ALL === saveType) {    yield* addRandomKeyTaskCmd(cmd);  }  if (cmd.getUrl()) {    result = true;  } else {    var buffer = cmd.getData();    yield storage.putObject(cmd.getSaveKey() + '/' + filename, buffer, buffer.length);    //delete data to prevent serialize into json    cmd.data = null;    result = (SAVE_TYPE_COMPLETE_ALL === saveType || SAVE_TYPE_COMPLETE === saveType);  }  return result;}function getSaveTask(cmd) {  cmd.setData(null);  var queueData = new commonDefines.TaskQueueData();  queueData.setCmd(cmd);  queueData.setToFile(constants.OUTPUT_NAME + '.' + formatChecker.getStringFromFormat(cmd.getOutputFormat()));  //todo paid  //if (cmd.vkey) {  //  bool  //  bPaid;  //  Signature.getVKeyParams(cmd.vkey, out bPaid);  //  oTaskQueueData.m_bPaid = bPaid;  //}  return queueData;}function getUpdateResponse(cmd) {  var updateTask = new taskResult.TaskResultData();  updateTask.key = cmd.getSaveKey() ? cmd.getSaveKey() : cmd.getDocId();  var statusInfo = cmd.getStatusInfo();  if (constants.NO_ERROR == statusInfo) {    updateTask.status = taskResult.FileStatus.Ok;  } else if (constants.CONVERT_DOWNLOAD == statusInfo) {    updateTask.status = taskResult.FileStatus.ErrToReload;  } else if (constants.CONVERT_NEED_PARAMS == statusInfo) {    updateTask.status = taskResult.FileStatus.NeedParams;  } else {    updateTask.status = taskResult.FileStatus.Err;  }  updateTask.statusInfo = statusInfo;  if (cmd.getTitle()) {    updateTask.title = cmd.getTitle();  }  return updateTask;}function* commandOpen(conn, cmd, outputData) {  var task = new taskResult.TaskResultData();  task.key = cmd.getDocId();  task.format = cmd.getFormat();  task.status = taskResult.FileStatus.WaitQueue;  task.statusInfo = constants.NO_ERROR;  task.title = cmd.getTitle();  var upsertRes = yield taskResult.upsert(task);  //var bCreate = (upsertRes.affectedRows == 1);  var bExist = (upsertRes.affectedRows > 1);  if (bExist) {    var selectRes = yield taskResult.select(task);    if (selectRes.length > 0) {      var row = selectRes[0];      yield* getOutputData(cmd, outputData, cmd.getDocId(), row.tr_status, row.tr_status_info, conn);    }  } else {    //add task    cmd.setOutputFormat(constants.AVS_OFFICESTUDIO_FILE_CANVAS);    cmd.setEmbeddedFonts(false);    var dataQueue = new commonDefines.TaskQueueData();    dataQueue.setCmd(cmd);    dataQueue.setToFile('Editor.bin');    yield* docsCoServer.addTask(dataQueue, constants.QUEUE_PRIORITY_HIGH);  }}function* commandReopen(cmd) {  var task = new taskResult.TaskResultData();  task.key = cmd.getDocId();  task.status = taskResult.FileStatus.WaitQueue;  task.statusInfo = constants.NO_ERROR;  var upsertRes = yield taskResult.update(task);  if (upsertRes.affectedRows > 0) {    //add task    cmd.setUrl(null);//url may expire    cmd.setSaveKey(cmd.getDocId());    cmd.setOutputFormat(constants.AVS_OFFICESTUDIO_FILE_CANVAS);    cmd.setEmbeddedFonts(false);    var dataQueue = new commonDefines.TaskQueueData();    dataQueue.setCmd(cmd);    dataQueue.setToFile('Editor.bin');    dataQueue.setFromSettings(true);    yield* docsCoServer.addTask(dataQueue, constants.QUEUE_PRIORITY_HIGH);  }}function* commandSave(cmd, outputData) {  var completeParts = yield* saveParts(cmd);  if (completeParts) {    var queueData = getSaveTask(cmd);    yield* docsCoServer.addTask(queueData, constants.QUEUE_PRIORITY_LOW);  }  outputData.setStatus('ok');  outputData.setData(cmd.getSaveKey());}function* commandSendMailMerge(cmd, outputData) {  var completeParts = yield* saveParts(cmd);  var isErr = false;  if (completeParts) {    isErr = true;    var getRes = yield* docsCoServer.getCallback(cmd.getDocId());    if (getRes) {      var mailMergeSend = cmd.getMailMergeSend();      mailMergeSend.setUrl(getRes.server.href);      mailMergeSend.setBaseUrl(getRes.baseUrl);      //меняем JsonKey и SaveKey, новый key нужет потому что за одну конвертацию делается часть, а json нужен всегда      mailMergeSend.setJsonKey(cmd.getSaveKey());      yield* addRandomKeyTaskCmd(cmd);      var queueData = getSaveTask(cmd);      yield* docsCoServer.addTask(queueData, constants.QUEUE_PRIORITY_LOW);      isErr = false;    }  }  if (isErr) {    outputData.setStatus('err');    outputData.setData(constants.UNKNOWN);  } else {    outputData.setStatus('ok');    outputData.setData(cmd.getSaveKey());  }}function* commandSfct(cmd, outputData) {  yield* addRandomKeyTaskCmd(cmd);  var queueData = getSaveTask(cmd);  queueData.setFromChanges(true);  yield* docsCoServer.addTask(queueData, constants.QUEUE_PRIORITY_LOW);  outputData.setStatus('ok');}function isDisplayedImage(strName) {  var res = 0;  if (strName) {    //шаблон display[N]image.ext    var findStr = constants.DISPLAY_PREFIX;    var index = strName.indexOf(findStr);    if (-1 != index) {      if (index + findStr.length < strName.length) {        var displayN = parseInt(strName[index + findStr.length]);        if (1 <= displayN && displayN <= 6) {          var imageIndex = index + findStr.length + 1;          if (imageIndex == strName.indexOf("image", imageIndex))            res = displayN;        }      }    }  }  return res;}function* commandImgurls(conn, cmd, outputData) {  var supportedFormats;  var urls;  var errorCode = constants.NO_ERROR;  var isImgUrl = 'imgurl' == cmd.getCommand();  if (isImgUrl) {    urls = [cmd.getData()];    supportedFormats = cfgTypesUpload || 'jpg';  } else {    urls = cmd.getData();    supportedFormats = cfgTypesCopy || 'jpg';  }  //todo Promise.all()  var displayedImageMap = {};//to make one imageIndex for ole object urls  var imageCount = 0;  var outputUrls = [];  for (var i = 0; i < urls.length; ++i) {    var urlSource = urls[i];    var urlParsed;    var data = undefined;    if (urlSource.startsWith('data:')) {      var delimiterIndex = urlSource.indexOf(',');      if (-1 != delimiterIndex && (urlSource.length - (delimiterIndex + 1)) * 0.75 <= cfgImageSize) {        data = new Buffer(urlSource.substring(delimiterIndex + 1), 'base64');      }    } else if(urlSource) {      //todo stream      data = yield utils.downloadUrlPromise(urlSource, cfgImageDownloadTimeout * 1000, cfgImageSize);      urlParsed = urlModule.parse(urlSource);    }    var outputUrl = {url: 'error', path: 'error'};    if (data) {      var format = formatChecker.getImageFormat(data);      var formatStr;      if (constants.AVS_OFFICESTUDIO_FILE_UNKNOWN == format && urlParsed) {        //bin, txt occur in ole object case        var ext = pathModule.extname(urlParsed.pathname);        if ('.bin' == ext || '.txt' == ext) {          formatStr = ext.substring(1);        }      } else {        formatStr = formatChecker.getStringFromFormat(format);      }      if (formatStr && -1 !== supportedFormats.indexOf(formatStr)) {        var userid = cmd.getUserId();        var imageIndex = cmd.getSaveIndex() + imageCount;        imageCount++;        var strLocalPath = 'media/' + utils.crc32(userid).toString(16) + '_';        if (urlParsed) {          var urlBasename = pathModule.basename(urlParsed.pathname);          var displayN = isDisplayedImage(urlBasename);          if (displayN > 0) {            var displayedImageName = urlBasename.substring(0, urlBasename.length - formatStr.length - 1);            var tempIndex = displayedImageMap[displayedImageName];            if (null != tempIndex) {              imageIndex = tempIndex;              imageCount--;            } else {              displayedImageMap[displayedImageName] = imageIndex;            }            strLocalPath += constants.DISPLAY_PREFIX + displayN;          }        }        strLocalPath += 'image' + imageIndex + '.' + formatStr;        var strPath = cmd.getDocId() + '/' + strLocalPath;        yield storage.putObject(strPath, data, data.length);        var imgUrl = yield storage.getSignedUrl(conn.baseUrl, strPath);        outputUrl = {url: imgUrl, path: strLocalPath};      }    }    if (isImgUrl && ('error' === outputUrl.url || 'error' === outputUrl.path)) {      errorCode = constants.UPLOAD_EXTENSION;      break;    }    outputUrls.push(outputUrl);  }  if (constants.NO_ERROR !== errorCode) {    outputData.setStatus('err');    outputData.setData(errorCode);  } else {    outputData.setStatus('ok');    outputData.setData(outputUrls);  }}function* commandSaveFromOrigin(conn, cmd) {  yield* addRandomKeyTaskCmd(cmd);  cmd.setOutputFormat(constants.AVS_OFFICESTUDIO_FILE_CROSSPLATFORM_PDF);  cmd.setUserConnectionId(conn.user.id);  var queueData = getSaveTask(cmd);  queueData.setFromOrigin(true);  yield* docsCoServer.addTask(queueData, constants.QUEUE_PRIORITY_LOW);}function* commandSfcCallback(cmd) {  var docId = cmd.getDocId();  logger.debug('Start commandSfcCallback: docId = %s', docId);  var saveKey = cmd.getSaveKey();  var statusInfo = cmd.getStatusInfo();  var getRes = yield* docsCoServer.getCallback(docId);  if (getRes) {    logger.debug('Callback commandSfcCallback: docId = %s callback = %s', docId, getRes.server.href);    var outputSfc = new OutputSfcData();    outputSfc.setKey(docId);    if (cmd.getUserId()) {      outputSfc.setUsers([cmd.getUserId()]);    }    if (constants.NO_ERROR != statusInfo && constants.CONVERT_CORRUPTED != statusInfo) {      outputSfc.setStatus(docsCoServer.c_oAscServerStatus.Corrupted);    } else {      try {        var data = yield storage.getObject(saveKey + '/changesHistory.json');        outputSfc.setChangeHistory(data.toString('utf-8'));        outputSfc.setUrl(yield storage.getSignedUrl(getRes.baseUrl, saveKey + '/' + cmd.getOutputPath()));        outputSfc.setChangeUrl(yield storage.getSignedUrl(getRes.baseUrl, saveKey + '/changes.zip'));      } catch (e) {        logger.error('Error commandSfcCallback: docId = %s\r\n%s', docId, e.stack);      }      if (outputSfc.getUrl() && outputSfc.getUsers().length > 0) {        outputSfc.setStatus(docsCoServer.c_oAscServerStatus.MustSave);      } else {        outputSfc.setStatus(docsCoServer.c_oAscServerStatus.Corrupted);      }    }    //if anybody in document stop save    var hasEditors = yield* docsCoServer.hasEditors(docId);    logger.debug('hasEditors commandSfcCallback: docId = %s hasEditors = %d', docId, hasEditors);    if (!hasEditors) {      var updateTask = new taskResult.TaskResultData();      updateTask.key = docId;      updateTask.status = taskResult.FileStatus.UpdateVersion;      updateTask.statusInfo = constants.NO_ERROR;      var updateRes = yield taskResult.update(updateTask);      if (updateRes.affectedRows > 0) {        yield docsCoServer.sendServerRequestPromise(docId, getRes.server, JSON.stringify(outputSfc));        yield* docsCoServer.deleteCallback(docId);      }    }  }  logger.debug('End commandSfcCallback: docId = %s', docId);}function* commandSendMMCallback(cmd) {  var docId = cmd.getDocId();  logger.debug('Start commandSendMMCallback: docId = %s', docId);  var saveKey = cmd.getSaveKey();  var statusInfo = cmd.getStatusInfo();  var outputSfc = new OutputSfcData();  outputSfc.setKey(docId);  if (constants.NO_ERROR == statusInfo) {    outputSfc.setStatus(docsCoServer.c_oAscServerStatus.MailMerge);  } else {    outputSfc.setStatus(docsCoServer.c_oAscServerStatus.Corrupted);  }  var mailMergeSendData = cmd.getMailMergeSend();  var outputMailMerge = new OutputMailMerge(mailMergeSendData);  outputSfc.setMailMerge(outputMailMerge);  outputSfc.setUsers([mailMergeSendData.getUserId()]);  var data = yield storage.getObject(saveKey + '/' + cmd.getOutputPath());  var xml = data.toString('utf8');  var files = xml.match(/[< ]file.*?\/>/g);  var recordRemain = (mailMergeSendData.getRecordTo() - mailMergeSendData.getRecordFrom() + 1);  var recordIndexStart = mailMergeSendData.getRecordCount() - recordRemain;  for (var i = 0; i < files.length; ++i) {    var file = files[i];    var fieldRes = /field=["'](.*?)["']/.exec(file);    outputMailMerge.setTo(fieldRes[1]);    outputMailMerge.setRecordIndex(recordIndexStart + i);    var pathRes = /path=["'](.*?)["']/.exec(file);    var signedUrl = yield storage.getSignedUrl(mailMergeSendData.getBaseUrl(), saveKey + '/' + pathRes[1]);    outputSfc.setUrl(signedUrl);    var server = docsCoServer.parseUrl(mailMergeSendData.getUrl());    yield docsCoServer.sendServerRequestPromise(docId, server, JSON.stringify(outputSfc));  }  var newRecordFrom = mailMergeSendData.getRecordFrom() + Math.max(files.length, 1);  if (newRecordFrom <= mailMergeSendData.getRecordTo()) {    mailMergeSendData.setRecordFrom(newRecordFrom);    yield* addRandomKeyTaskCmd(cmd);    var queueData = getSaveTask(cmd);    yield* docsCoServer.addTask(queueData, constants.QUEUE_PRIORITY_LOW);  } else {    logger.debug('End MailMerge: docId = %s', docId);  }  logger.debug('End commandSendMMCallback: docId = %s', docId);}exports.openDocument = function(conn, input) {  utils.spawn(function* () {    var outputData;    var docId = conn ? conn.docId : 'null';    try {      var startDate = null;      if(clientStatsD) {        startDate = new Date();      }      var cmd = new commonDefines.InputCommand(input.message);      logger.debug('Start command: docId = %s %s', docId, JSON.stringify(cmd));      outputData = new OutputData(cmd.getCommand());      switch (cmd.getCommand()) {        case 'open':          //yield utils.sleep(5000);          yield* commandOpen(conn, cmd, outputData);          break;        case 'reopen':          yield* commandReopen(cmd);          break;        case 'savefromorigin':          yield* commandSaveFromOrigin(conn, cmd);          break;        case 'imgurl':        case 'imgurls':          yield* commandImgurls(conn, cmd, outputData);          break;        default:          outputData.setStatus('err');          outputData.setData(constants.UNKNOWN);          break;      }      if(clientStatsD) {        clientStatsD.timing('coauth.openDocument.' + cmd.getCommand(), new Date() - startDate);      }    }    catch (e) {      logger.error('Error openDocument: docId = %s\r\n%s', docId, e.stack);      if (!outputData) {        outputData = new OutputData();      }      outputData.setStatus('err');      outputData.setData(constants.UNKNOWN);    }    finally {      if (outputData && outputData.getStatus()) {        logger.debug('Response command: docId = %s %s', docId, JSON.stringify(outputData));        docsCoServer.sendData(conn, new OutputDataWrap('documentOpen', outputData));      }      logger.debug('End command: docId = %s', docId);    }  });};exports.downloadAs = function(req, res) {  utils.spawn(function* () {    var docId = 'null';    try {      var startDate = null;      if(clientStatsD) {        startDate = new Date();      }      var strCmd = req.query['cmd'];      var cmd = new commonDefines.InputCommand(JSON.parse(strCmd));      docId = cmd.getDocId();      logger.debug('Start downloadAs: docId = %s %s', docId, strCmd);      cmd.setData(req.body);      var outputData = new OutputData(cmd.getCommand());      switch (cmd.getCommand()) {        case 'save':          yield* commandSave(cmd, outputData);          break;        case 'sendmm':          yield* commandSendMailMerge(cmd, outputData);          break;        case 'sfct':          yield* commandSfct(cmd, outputData);          break;        default:          outputData.setStatus('err');          outputData.setData(constants.UNKNOWN);          break;      }      var strRes = JSON.stringify(outputData);      res.send(strRes);      logger.debug('End downloadAs: docId = %s %s', docId, strRes);      if(clientStatsD) {        clientStatsD.timing('coauth.downloadAs.' + cmd.getCommand(), new Date() - startDate);      }    }    catch (e) {      logger.error('Error downloadAs: docId = %s\r\n%s', docId, e.stack);      res.sendStatus(400);    }  });};exports.saveFromChanges = function(docId, optFormat) {  utils.spawn(function* () {    try {      var startDate = null;      if(clientStatsD) {        startDate = new Date();      }      logger.debug('Start saveFromChanges: docId = %s', docId);      if (null == optFormat) {        optFormat = constants.AVS_OFFICESTUDIO_FILE_OTHER_TEAMLAB_INNER;      }      var cmd = new commonDefines.InputCommand();      cmd.setCommand('sfc');      cmd.setDocId(docId);      cmd.setOutputFormat(optFormat);      yield* addRandomKeyTaskCmd(cmd);      var queueData = getSaveTask(cmd);      queueData.setFromChanges(true);      yield* docsCoServer.addTask(queueData, constants.QUEUE_PRIORITY_NORMAL);      logger.debug('AddTask saveFromChanges: docId = %s', docId);      if(clientStatsD) {        clientStatsD.timing('coauth.saveFromChanges', new Date() - startDate);      }    }    catch (e) {      logger.error('Error saveFromChanges: docId = %s\r\n%s', docId, e.stack);    }  });};exports.receiveTask = function(data, dataRaw) {  utils.spawn(function* () {    var docId = 'null';    try {      var task = new commonDefines.TaskQueueData(JSON.parse(data));      if (task) {        var cmd = task.getCmd();        docId = cmd.getDocId();        logger.debug('Start receiveTask: docId = %s %s', docId, data);        var updateTask = getUpdateResponse(cmd);        var updateRes = yield taskResult.update(updateTask);        if (updateRes.affectedRows > 0) {          var outputData = new OutputData(cmd.getCommand());          var command = cmd.getCommand();          var additionalOutput = {needUrlKey: null, needUrlMethod: null};          if ('open' == command || 'reopen' == command) {            //yield utils.sleep(5000);            yield* getOutputData(cmd, outputData, cmd.getDocId(), updateTask.status,              updateTask.statusInfo, null, additionalOutput);          } else if ('save' == command || 'savefromorigin' == command || 'sfct' == command) {            yield* getOutputData(cmd, outputData, cmd.getSaveKey(), updateTask.status,              updateTask.statusInfo, null, additionalOutput);          } else if ('sfc' == command) {            yield* commandSfcCallback(cmd);          } else if ('sendmm' == command) {            yield* commandSendMMCallback(cmd);          } else if ('conv' == command) {            //nothing          }          if (outputData.getStatus()) {            logger.debug('Send receiveTask: docId = %s %s', docId, JSON.stringify(outputData));            var output = new OutputDataWrap('documentOpen', outputData);            yield* docsCoServer.publish({              type: docsCoServer.PublishType.receiveTask, cmd: cmd, output: output,              needUrlKey: additionalOutput.needUrlKey, needUrlMethod: additionalOutput.needUrlMethod            });          }        }        yield* docsCoServer.removeResponse(dataRaw);        logger.debug('End receiveTask: docId = %s', docId);      }    } catch (err) {      logger.debug('Error receiveTask: docId = %s\r\n%s', docId, err.stack);    }  });};exports.OutputDataWrap = OutputDataWrap;exports.OutputData = OutputData;